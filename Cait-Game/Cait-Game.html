<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cait-Lab Game 贪吃蛇</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #111;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            padding: 10px;
        }
        
        .header {
            text-align: center;
            padding: 15px;
            width: 100%;
            background: linear-gradient(90deg, #1a1a2e, #16213e);
            border-bottom: 3px solid #00ffaa;
            box-shadow: 0 5px 15px rgba(0, 255, 170, 0.3);
            margin-bottom: 15px;
            border-radius: 10px;
        }
        
        .title {
            font-size: 2.8rem;
            background: linear-gradient(90deg, #00ffaa, #00ccff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 10px rgba(0, 255, 170, 0.5);
            letter-spacing: 2px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #aaffee;
            margin-top: 5px;
        }
        
        .game-container {
            display: flex;
            width: 98vw;
            height: 85vh;
            gap: 15px;
        }
        
        .game-board {
            flex: 1;
            position: relative;
            background-color: #000;
            border: 3px solid #333;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 100, 255, 0.2);
        }
        
        #game-canvas {
            display: block;
            background-color: #000;
        }
        
        .info-panel {
            width: 280px;
            background-color: #1a1a2e;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #333;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: 0 0 20px rgba(0, 100, 255, 0.2);
        }
        
        .panel-section {
            background-color: #16213e;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #00ffaa;
        }
        
        .section-title {
            color: #00ffaa;
            font-size: 1.3rem;
            margin-bottom: 12px;
            border-bottom: 1px solid #2d4059;
            padding-bottom: 5px;
        }
        
        .score-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        .player-name {
            font-weight: bold;
        }
        
        .player-you {
            color: #00ffaa;
        }
        
        .player-ai1 {
            color: #ff5555;
        }
        
        .player-ai2 {
            color: #5555ff;
        }
        
        .player-ai3 {
            color: #ffaa00;
        }
        
        .controls-list {
            list-style-type: none;
            padding-left: 5px;
        }
        
        .controls-list li {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        
        .key {
            display: inline-block;
            background-color: #333;
            padding: 3px 8px;
            border-radius: 4px;
            margin-right: 10px;
            font-family: monospace;
            min-width: 40px;
            text-align: center;
            border: 1px solid #555;
        }
        
        .game-rules {
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        .game-rules p {
            margin-bottom: 8px;
        }
        
        .rule-important {
            color: #ff5555;
            font-weight: bold;
        }
        
        .status {
            text-align: center;
            padding: 15px;
            font-size: 1.5rem;
            color: #00ffaa;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }
        
        button {
            background: linear-gradient(90deg, #00b894, #00a085);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            flex: 1;
        }
        
        button:hover {
            background: linear-gradient(90deg, #00ffaa, #00ccff);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 170, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button#restart-btn {
            background: linear-gradient(90deg, #e74c3c, #c0392b);
        }
        
        button#restart-btn:hover {
            background: linear-gradient(90deg, #ff6b6b, #ee5a52);
        }
        
        .footer {
            margin-top: 15px;
            text-align: center;
            color: #666;
            font-size: 0.9rem;
            padding: 10px;
        }
        
        /* 闪烁动画 */
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .blinking {
            animation: blink 0.3s 3;
        }
        
        .respawn-notice {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: #ffaa00;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1.2rem;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">Cait-Lab Game 贪吃蛇</h1>
        <div class="subtitle">玩家 vs 3个人机 - 避开其他蛇的身体，收集食物，成为最长的蛇！</div>
    </div>
    
    <div class="status" id="status">游戏准备中... 使用方向键控制你的蛇</div>
    
    <div class="game-container">
        <div class="game-board">
            <canvas id="game-canvas"></canvas>
        </div>
        
        <div class="info-panel">
            <div class="panel-section">
                <h3 class="section-title">游戏状态</h3>
                <div id="scoreboard">
                    <!-- 分数将通过JavaScript动态生成 -->
                </div>
            </div>
            
            <div class="panel-section">
                <h3 class="section-title">控制方式</h3>
                <ul class="controls-list">
                    <li><span class="key">↑</span> 向上移动</li>
                    <li><span class="key">↓</span> 向下移动</li>
                    <li><span class="key">←</span> 向左移动</li>
                    <li><span class="key">→</span> 向右移动</li>
                    <li><span class="key">空格</span> 暂停/继续游戏</li>
                    <li><span class="key">R</span> 重新开始游戏</li>
                </ul>
            </div>
            
            <div class="panel-section">
                <h3 class="section-title">游戏规则</h3>
                <div class="game-rules">
                    <p>• 玩家可以碰自己的身体，但不能碰其他蛇的身体</p>
                    <p>• 人机死亡后会闪烁并在远离玩家的位置重生</p>
                    <p>• 玩家死亡后游戏结束</p>
                    <p>• 吃到食物可以增加长度和分数</p>
                    <p class="rule-important">• 避免撞到其他蛇的身体！</p>
                </div>
            </div>
            
            <div class="buttons">
                <button id="start-btn">开始游戏</button>
                <button id="restart-btn">重新开始</button>
            </div>
        </div>
    </div>
    
    <div class="footer">
        Cait-Lab Game 贪吃蛇 | 玩家控制绿色蛇，击败3个人机对手
    </div>

    <script>
        // 获取Canvas元素和上下文
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // 设置Canvas尺寸为超大屏幕
        canvas.width = document.querySelector('.game-board').offsetWidth;
        canvas.height = document.querySelector('.game-board').offsetHeight;
        
        // 游戏状态
        let gameRunning = false;
        let gamePaused = false;
        let playerAlive = true;
        let lastRenderTime = 0;
        const gameSpeed = 10; // 游戏速度，值越大越快
        
        // 游戏配置
        const gridSize = 20; // 网格大小
        const foodCount = 15; // 食物数量
        const initialSnakeLength = 5; // 初始蛇长度
        
        // 玩家和人机
        const player = {
            name: "玩家",
            color: "#00ffaa",
            body: [],
            direction: { x: 1, y: 0 },
            nextDirection: { x: 1, y: 0 },
            score: 0,
            isAI: false,
            alive: true
        };
        
        const aiPlayers = [
            { 
                name: "人机1", 
                color: "#ff5555", 
                body: [], 
                direction: { x: -1, y: 0 }, 
                nextDirection: { x: -1, y: 0 },
                score: 0, 
                isAI: true,
                alive: true,
                aiStrategy: "aggressive" // aggressive, cautious, random
            },
            { 
                name: "人机2", 
                color: "#5555ff", 
                body: [], 
                direction: { x: 0, y: 1 }, 
                nextDirection: { x: 0, y: 1 },
                score: 0, 
                isAI: true,
                alive: true,
                aiStrategy: "cautious"
            },
            { 
                name: "人机3", 
                color: "#ffaa00", 
                body: [], 
                direction: { x: 0, y: -1 }, 
                nextDirection: { x: 0, y: -1 },
                score: 0, 
                isAI: true,
                alive: true,
                aiStrategy: "random"
            }
        ];
        
        // 所有玩家数组
        const allPlayers = [player, ...aiPlayers];
        
        // 食物数组
        let foods = [];
        
        // 初始化游戏
        function initGame() {
            // 重置玩家状态
            player.score = 0;
            player.alive = true;
            player.body = [];
            player.direction = { x: 1, y: 0 };
            player.nextDirection = { x: 1, y: 0 };
            
            // 重置AI状态
            aiPlayers.forEach(ai => {
                ai.score = 0;
                ai.alive = true;
                ai.body = [];
                ai.direction = { x: Math.random() > 0.5 ? 1 : -1, y: 0 };
                ai.nextDirection = { x: ai.direction.x, y: 0 };
            });
            
            // 初始化蛇身体
            initSnakes();
            
            // 生成食物
            foods = [];
            generateFood();
            
            // 更新状态显示
            updateStatus("游戏开始！避开其他蛇的身体，收集食物！");
            
            // 更新分数板
            updateScoreboard();
            
            playerAlive = true;
            gameRunning = true;
            gamePaused = false;
        }
        
        // 初始化蛇的位置
        function initSnakes() {
            // 玩家初始位置在左下角
            for (let i = 0; i < initialSnakeLength; i++) {
                player.body.push({
                    x: Math.floor(gridSize * 1.5) - i,
                    y: Math.floor(canvas.height / gridSize) - 5
                });
            }
            
            // AI初始位置分散在不同区域
            const positions = [
                { x: Math.floor(canvas.width / gridSize) - 10, y: Math.floor(gridSize * 1.5) }, // 右上
                { x: Math.floor(canvas.width / gridSize) - 10, y: Math.floor(canvas.height / gridSize) - 5 }, // 右下
                { x: Math.floor(gridSize * 1.5), y: Math.floor(gridSize * 1.5) } // 左上
            ];
            
            aiPlayers.forEach((ai, index) => {
                for (let i = 0; i < initialSnakeLength; i++) {
                    ai.body.push({
                        x: positions[index].x - i * (ai.direction.x > 0 ? -1 : 1),
                        y: positions[index].y - i * (ai.direction.y > 0 ? -1 : 1)
                    });
                }
            });
        }
        
        // 生成食物
        function generateFood() {
            // 清除现有食物
            foods = [];
            
            // 生成新食物
            for (let i = 0; i < foodCount; i++) {
                let newFood;
                let foodValid = false;
                
                // 确保食物不生成在蛇身上
                while (!foodValid) {
                    newFood = {
                        x: Math.floor(Math.random() * (canvas.width / gridSize)),
                        y: Math.floor(Math.random() * (canvas.height / gridSize)),
                        color: getRandomFoodColor()
                    };
                    
                    foodValid = true;
                    
                    // 检查是否与任何蛇身体重叠
                    for (const p of allPlayers) {
                        for (const segment of p.body) {
                            if (segment.x === newFood.x && segment.y === newFood.y) {
                                foodValid = false;
                                break;
                            }
                        }
                        if (!foodValid) break;
                    }
                    
                    // 检查是否与其他食物重叠
                    for (const food of foods) {
                        if (food.x === newFood.x && food.y === newFood.y) {
                            foodValid = false;
                            break;
                        }
                    }
                }
                
                foods.push(newFood);
            }
        }
        
        // 获取随机食物颜色
        function getRandomFoodColor() {
            const colors = ["#ff5555", "#55ff55", "#5555ff", "#ffff55", "#ff55ff", "#55ffff"];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        // 更新游戏状态
        function update() {
            if (!gameRunning || gamePaused) return;
            
            // 更新玩家方向
            player.direction = { ...player.nextDirection };
            
            // 移动所有存活的蛇
            for (const p of allPlayers) {
                if (!p.alive) continue;
                
                // AI玩家计算下一步移动
                if (p.isAI) {
                    calculateAIMove(p);
                    p.direction = { ...p.nextDirection };
                }
                
                // 移动蛇
                moveSnake(p);
                
                // 检查是否吃到食物
                checkFoodCollision(p);
                
                // 检查碰撞
                checkCollisions(p);
            }
            
            // 更新分数板
            updateScoreboard();
        }
        
        // 移动蛇
        function moveSnake(snake) {
            // 添加新头部
            const head = { ...snake.body[0] };
            head.x += snake.direction.x;
            head.y += snake.direction.y;
            
            // 处理边界穿越
            if (head.x < 0) head.x = Math.floor(canvas.width / gridSize) - 1;
            if (head.x >= Math.floor(canvas.width / gridSize)) head.x = 0;
            if (head.y < 0) head.y = Math.floor(canvas.height / gridSize) - 1;
            if (head.y >= Math.floor(canvas.height / gridSize)) head.y = 0;
            
            // 将新头部添加到身体前端
            snake.body.unshift(head);
            
            // 如果没有吃到食物，移除尾部
            if (!snake.grow) {
                snake.body.pop();
            } else {
                snake.grow = false;
            }
        }
        
        // 计算AI移动
        function calculateAIMove(ai) {
            const head = ai.body[0];
            const directions = [
                { x: 1, y: 0 },   // 右
                { x: -1, y: 0 },  // 左
                { x: 0, y: 1 },   // 下
                { x: 0, y: -1 }   // 上
            ];
            
            // 避免反向移动
            const oppositeDir = { x: -ai.direction.x, y: -ai.direction.y };
            const validDirections = directions.filter(dir => 
                !(dir.x === oppositeDir.x && dir.y === oppositeDir.y)
            );
            
            // 根据AI策略选择方向
            let chosenDirection;
            
            if (ai.aiStrategy === "random") {
                // 随机选择方向
                chosenDirection = validDirections[Math.floor(Math.random() * validDirections.length)];
            } else if (ai.aiStrategy === "aggressive") {
                // 积极寻找食物
                chosenDirection = findFoodDirection(ai, head, validDirections);
            } else {
                // 谨慎模式：避免其他蛇
                chosenDirection = avoidSnakesDirection(ai, head, validDirections);
            }
            
            // 如果选择的方向会导致碰撞，尝试其他方向
            if (chosenDirection && wouldCollide(ai, head, chosenDirection)) {
                const safeDirections = validDirections.filter(dir => 
                    !wouldCollide(ai, head, dir)
                );
                
                if (safeDirections.length > 0) {
                    chosenDirection = safeDirections[Math.floor(Math.random() * safeDirections.length)];
                } else {
                    // 没有安全方向，随机选择
                    chosenDirection = validDirections[Math.floor(Math.random() * validDirections.length)];
                }
            }
            
            if (chosenDirection) {
                ai.nextDirection = chosenDirection;
            }
        }
        
        // 寻找食物方向
        function findFoodDirection(ai, head, directions) {
            if (foods.length === 0) return directions[0];
            
            // 找到最近的食物
            let closestFood = foods[0];
            let closestDistance = Math.abs(head.x - closestFood.x) + Math.abs(head.y - closestFood.y);
            
            for (let i = 1; i < foods.length; i++) {
                const distance = Math.abs(head.x - foods[i].x) + Math.abs(head.y - foods[i].y);
                if (distance < closestDistance) {
                    closestFood = foods[i];
                    closestDistance = distance;
                }
            }
            
            // 选择朝向食物的方向
            const dx = closestFood.x - head.x;
            const dy = closestFood.y - head.y;
            
            // 优先考虑减少距离的方向
            const scoredDirections = directions.map(dir => {
                let score = 0;
                const newX = head.x + dir.x;
                const newY = head.y + dir.y;
                
                // 计算新位置到食物的距离
                const newDistance = Math.abs(newX - closestFood.x) + Math.abs(newY - closestFood.y);
                
                // 如果更接近食物，得分更高
                if (newDistance < closestDistance) score += 10;
                
                // 避免边界
                if (newX < 2 || newX >= Math.floor(canvas.width / gridSize) - 2) score -= 2;
                if (newY < 2 || newY >= Math.floor(canvas.height / gridSize) - 2) score -= 2;
                
                // 避免其他蛇
                for (const p of allPlayers) {
                    if (p === ai || !p.alive) continue;
                    
                    for (const segment of p.body) {
                        if (segment.x === newX && segment.y === newY) {
                            score -= 100; // 避免碰撞
                            break;
                        }
                    }
                }
                
                return { dir, score };
            });
            
            // 选择得分最高的方向
            scoredDirections.sort((a, b) => b.score - a.score);
            return scoredDirections[0].dir;
        }
        
        // 避免其他蛇的方向
        function avoidSnakesDirection(ai, head, directions) {
            // 评估每个方向的安全性
            const scoredDirections = directions.map(dir => {
                let score = 0;
                const newX = head.x + dir.x;
                const newY = head.y + dir.y;
                
                // 检查是否靠近其他蛇
                for (const p of allPlayers) {
                    if (p === ai || !p.alive) continue;
                    
                    for (const segment of p.body) {
                        const distance = Math.abs(newX - segment.x) + Math.abs(newY - segment.y);
                        
                        // 如果太靠近其他蛇，降低得分
                        if (distance < 3) {
                            score -= (5 - distance);
                        }
                    }
                }
                
                // 寻找食物
                if (foods.length > 0) {
                    const closestFood = foods.reduce((closest, food) => {
                        const distance = Math.abs(newX - food.x) + Math.abs(newY - food.y);
                        return distance < closest.distance ? { food, distance } : closest;
                    }, { food: foods[0], distance: Infinity });
                    
                    if (closestFood.distance < 10) {
                        score += 5;
                    }
                }
                
                // 避免边界
                if (newX < 3 || newX >= Math.floor(canvas.width / gridSize) - 3) score -= 1;
                if (newY < 3 || newY >= Math.floor(canvas.height / gridSize) - 3) score -= 1;
                
                return { dir, score };
            });
            
            // 选择得分最高的方向
            scoredDirections.sort((a, b) => b.score - a.score);
            return scoredDirections[0].dir;
        }
        
        // 检查方向是否会导致碰撞
        function wouldCollide(snake, head, direction) {
            const newX = head.x + direction.x;
            const newY = head.y + direction.y;
            
            // 检查边界
            if (newX < 0 || newX >= Math.floor(canvas.width / gridSize) || 
                newY < 0 || newY >= Math.floor(canvas.height / gridSize)) {
                return false; // 边界穿越不算碰撞
            }
            
            // 检查与其他蛇的碰撞（不包括自己）
            for (const p of allPlayers) {
                if (!p.alive) continue;
                
                // 检查蛇身体（对于自己，跳过头部）
                const startIndex = (p === snake) ? 1 : 0;
                
                for (let i = startIndex; i < p.body.length; i++) {
                    if (p.body[i].x === newX && p.body[i].y === newY) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // 检查食物碰撞
        function checkFoodCollision(snake) {
            const head = snake.body[0];
            
            for (let i = 0; i < foods.length; i++) {
                if (foods[i].x === head.x && foods[i].y === head.y) {
                    // 吃到食物
                    snake.score += 10;
                    snake.grow = true;
                    
                    // 移除被吃掉的食
                    foods.splice(i, 1);
                    
                    // 生成新食物
                    generateFood();
                    
                    // 更新状态显示
                    if (!snake.isAI) {
                        updateStatus("吃到食物！长度+1，分数+10");
                    }
                    
                    break;
                }
            }
        }
        
        // 检查碰撞
        function checkCollisions(snake) {
            const head = snake.body[0];
            
            // 检查与其他蛇的碰撞
            for (const p of allPlayers) {
                if (!p.alive || p === snake) continue;
                
                // 检查蛇身体（对于自己，跳过头部）
                const startIndex = (p === snake) ? 1 : 0;
                
                for (let i = startIndex; i < p.body.length; i++) {
                    if (p.body[i].x === head.x && p.body[i].y === head.y) {
                        // 发生碰撞
                        if (snake === player) {
                            // 玩家死亡
                            snake.alive = false;
                            playerAlive = false;
                            gameRunning = false;
                            updateStatus("游戏结束！你撞到了" + p.name + "的身体");
                        } else if (snake.isAI) {
                            // AI死亡
                            snake.alive = false;
                            respawnAI(snake);
                        }
                        return;
                    }
                }
            }
        }
        
        // AI重生
        function respawnAI(ai) {
            // 显示重生消息
            const respawnNotice = document.createElement('div');
            respawnNotice.className = 'respawn-notice';
            respawnNotice.textContent = `${ai.name} 重生中...`;
            respawnNotice.style.left = '50%';
            respawnNotice.style.top = '50%';
            respawnNotice.style.transform = 'translate(-50%, -50%)';
            document.querySelector('.game-board').appendChild(respawnNotice);
            
            // 闪烁效果
            ai.body.forEach((segment, index) => {
                setTimeout(() => {
                    segment.blink = true;
                }, index * 50);
            });
            
            // 3秒后重生
            setTimeout(() => {
                // 移除重生消息
                if (respawnNotice.parentNode) {
                    respawnNotice.parentNode.removeChild(respawnNotice);
                }
                
                // 在远离玩家的位置重生
                let newHead;
                let positionValid = false;
                const maxAttempts = 100;
                let attempts = 0;
                
                // 寻找远离玩家的位置
                const playerHead = player.body[0];
                
                while (!positionValid && attempts < maxAttempts) {
                    attempts++;
                    
                    // 随机生成位置
                    newHead = {
                        x: Math.floor(Math.random() * (canvas.width / gridSize)),
                        y: Math.floor(Math.random() * (canvas.height / gridSize))
                    };
                    
                    // 检查是否远离玩家
                    const distanceToPlayer = Math.abs(newHead.x - playerHead.x) + Math.abs(newHead.y - playerHead.y);
                    
                    // 至少距离玩家15个单位
                    if (distanceToPlayer < 15) continue;
                    
                    // 检查是否与其他蛇重叠
                    positionValid = true;
                    for (const p of allPlayers) {
                        if (!p.alive || p === ai) continue;
                        
                        for (const segment of p.body) {
                            if (segment.x === newHead.x && segment.y === newHead.y) {
                                positionValid = false;
                                break;
                            }
                        }
                        
                        if (!positionValid) break;
                    }
                }
                
                // 如果找不到合适位置，使用默认位置
                if (!positionValid) {
                    newHead = {
                        x: Math.floor(canvas.width / gridSize) - 10,
                        y: Math.floor(canvas.height / gridSize) - 10
                    };
                }
                
                // 重置AI蛇
                ai.body = [];
                ai.direction = { x: 1, y: 0 };
                ai.nextDirection = { x: 1, y: 0 };
                ai.alive = true;
                
                // 设置新的身体
                for (let i = 0; i < initialSnakeLength; i++) {
                    ai.body.push({
                        x: newHead.x - i,
                        y: newHead.y
                    });
                }
                
                // 更新状态显示
                updateStatus(`${ai.name} 在远处重生了！`);
                
                // 更新分数板
                updateScoreboard();
                
            }, 3000);
        }
        
        // 绘制游戏
        function draw() {
            // 清空画布
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制网格
            drawGrid();
            
            // 绘制食物
            drawFood();
            
            // 绘制所有蛇
            for (const p of allPlayers) {
                if (p.alive) {
                    drawSnake(p);
                }
            }
            
            // 绘制分数
            drawScores();
        }
        
        // 绘制网格
        function drawGrid() {
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 0.5;
            
            // 垂直线
            for (let x = 0; x <= canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // 水平线
            for (let y = 0; y <= canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        // 绘制食物
        function drawFood() {
            for (const food of foods) {
                ctx.fillStyle = food.color;
                ctx.beginPath();
                const centerX = food.x * gridSize + gridSize / 2;
                const centerY = food.y * gridSize + gridSize / 2;
                const radius = gridSize / 2 - 2;
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // 添加光泽效果
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(centerX - radius/3, centerY - radius/3, radius/3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // 绘制蛇
        function drawSnake(snake) {
            // 绘制身体
            for (let i = 0; i < snake.body.length; i++) {
                const segment = snake.body[i];
                
                // 闪烁效果
                if (segment.blink) {
                    if (Math.floor(Date.now() / 100) % 2 === 0) {
                        continue; // 跳过绘制，实现闪烁效果
                    }
                    
                    // 闪烁几次后移除闪烁标记
                    if (Date.now() - (segment.blinkStart || Date.now()) > 1500) {
                        segment.blink = false;
                    }
                }
                
                // 设置颜色
                ctx.fillStyle = snake.color;
                
                // 绘制身体段
                ctx.fillRect(
                    segment.x * gridSize + 1, 
                    segment.y * gridSize + 1, 
                    gridSize - 2, 
                    gridSize - 2
                );
                
                // 头部特殊绘制
                if (i === 0) {
                    // 绘制眼睛
                    ctx.fillStyle = '#fff';
                    const eyeSize = gridSize / 5;
                    
                    // 根据方向确定眼睛位置
                    let eye1X, eye1Y, eye2X, eye2Y;
                    
                    if (snake.direction.x === 1) { // 向右
                        eye1X = segment.x * gridSize + gridSize - eyeSize - 2;
                        eye1Y = segment.y * gridSize + gridSize / 3;
                        eye2X = segment.x * gridSize + gridSize - eyeSize - 2;
                        eye2Y = segment.y * gridSize + 2 * gridSize / 3 - eyeSize;
                    } else if (snake.direction.x === -1) { // 向左
                        eye1X = segment.x * gridSize + 2;
                        eye1Y = segment.y * gridSize + gridSize / 3;
                        eye2X = segment.x * gridSize + 2;
                        eye2Y = segment.y * gridSize + 2 * gridSize / 3 - eyeSize;
                    } else if (snake.direction.y === 1) { // 向下
                        eye1X = segment.x * gridSize + gridSize / 3;
                        eye1Y = segment.y * gridSize + gridSize - eyeSize - 2;
                        eye2X = segment.x * gridSize + 2 * gridSize / 3 - eyeSize;
                        eye2Y = segment.y * gridSize + gridSize - eyeSize - 2;
                    } else { // 向上
                        eye1X = segment.x * gridSize + gridSize / 3;
                        eye1Y = segment.y * gridSize + 2;
                        eye2X = segment.x * gridSize + 2 * gridSize / 3 - eyeSize;
                        eye2Y = segment.y * gridSize + 2;
                    }
                    
                    ctx.fillRect(eye1X, eye1Y, eyeSize, eyeSize);
                    ctx.fillRect(eye2X, eye2Y, eyeSize, eyeSize);
                    
                    // 绘制瞳孔
                    ctx.fillStyle = '#000';
                    ctx.fillRect(eye1X + eyeSize/4, eye1Y + eyeSize/4, eyeSize/2, eyeSize/2);
                    ctx.fillRect(eye2X + eyeSize/4, eye2Y + eyeSize/4, eyeSize/2, eyeSize/2);
                }
            }
        }
        
        // 绘制分数
        function drawScores() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 200, 100);
            
            ctx.font = '16px Arial';
            ctx.fillStyle = '#fff';
            ctx.fillText('当前分数:', 20, 30);
            
            let yPos = 55;
            for (const p of allPlayers) {
                if (p.alive) {
                    ctx.fillStyle = p.color;
                    ctx.fillText(`${p.name}: ${p.score} (长度: ${p.body.length})`, 20, yPos);
                } else {
                    ctx.fillStyle = '#888';
                    ctx.fillText(`${p.name}: ${p.score} (死亡)`, 20, yPos);
                }
                yPos += 20;
            }
        }
        
        // 更新分数板
        function updateScoreboard() {
            const scoreboard = document.getElementById('scoreboard');
            scoreboard.innerHTML = '';
            
            for (const p of allPlayers) {
                const scoreItem = document.createElement('div');
                scoreItem.className = 'score-item';
                
                const nameSpan = document.createElement('span');
                nameSpan.className = `player-name ${p === player ? 'player-you' : 
                                    p === aiPlayers[0] ? 'player-ai1' : 
                                    p === aiPlayers[1] ? 'player-ai2' : 'player-ai3'}`;
                nameSpan.textContent = p.name + (p === player ? ' (你)' : '');
                
                const scoreSpan = document.createElement('span');
                scoreSpan.className = 'player-score';
                scoreSpan.textContent = `${p.score} 分 (${p.body.length}格)`;
                
                if (!p.alive) {
                    scoreSpan.textContent += ' [死亡]';
                    scoreSpan.style.color = '#888';
                }
                
                scoreItem.appendChild(nameSpan);
                scoreItem.appendChild(scoreSpan);
                scoreboard.appendChild(scoreItem);
            }
        }
        
        // 更新状态显示
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        // 游戏主循环
        function gameLoop(currentTime) {
            if (lastRenderTime === 0) {
                lastRenderTime = currentTime;
            }
            
            const deltaTime = currentTime - lastRenderTime;
            
            if (deltaTime > 1000 / gameSpeed) {
                update();
                draw();
                lastRenderTime = currentTime;
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // 键盘控制
        function handleKeyDown(event) {
            if (!gameRunning) return;
            
            switch(event.key) {
                case 'ArrowUp':
                    if (player.direction.y === 0) {
                        player.nextDirection = { x: 0, y: -1 };
                    }
                    event.preventDefault();
                    break;
                    
                case 'ArrowDown':
                    if (player.direction.y === 0) {
                        player.nextDirection = { x: 0, y: 1 };
                    }
                    event.preventDefault();
                    break;
                    
                case 'ArrowLeft':
                    if (player.direction.x === 0) {
                        player.nextDirection = { x: -1, y: 0 };
                    }
                    event.preventDefault();
                    break;
                    
                case 'ArrowRight':
                    if (player.direction.x === 0) {
                        player.nextDirection = { x: 1, y: 0 };
                    }
                    event.preventDefault();
                    break;
                    
                case ' ':
                case 'Spacebar':
                    gamePaused = !gamePaused;
                    updateStatus(gamePaused ? "游戏暂停" : "游戏继续");
                    event.preventDefault();
                    break;
                    
                case 'r':
                case 'R':
                    initGame();
                    event.preventDefault();
                    break;
            }
        }
        
        // 窗口大小调整处理
        function handleResize() {
            // 保存游戏状态
            const wasRunning = gameRunning;
            gameRunning = false;
            
            // 调整Canvas大小
            canvas.width = document.querySelector('.game-board').offsetWidth;
            canvas.height = document.querySelector('.game-board').offsetHeight;
            
            // 重新开始游戏
            if (wasRunning) {
                initGame();
            }
        }
        
        // 初始化
        function init() {
            // 添加事件监听器
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('resize', handleResize);
            
            // 按钮事件
            document.getElementById('start-btn').addEventListener('click', () => {
                if (!gameRunning) {
                    initGame();
                }
            });
            
            document.getElementById('restart-btn').addEventListener('click', initGame);
            
            // 初始绘制
            draw();
            
            // 开始游戏循环
            requestAnimationFrame(gameLoop);
            
            // 初始状态
            updateStatus("点击「开始游戏」按钮开始游戏，使用方向键控制");
            updateScoreboard();
        }
        
        // 启动游戏
        init();
    </script>
</body>
</html>