<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¤¾åŒºèŠå¤© - Cait-Lab</title>
    <style>
        /* æ ·å¼éƒ¨åˆ†ä¿æŒä¸å˜ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Microsoft Yahei", sans-serif;
        }

        body {
            background-color: #f5f7fa;
            padding: 20px;
        }

        .chat-container {
            max-width: 800px;
            margin: 0 auto;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .chat-header {
            padding: 15px 20px;
            background-color: #0078d4;
            color: #fff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header h3 {
            font-size: 18px;
            font-weight: 500;
        }

        .user-info {
            font-size: 14px;
        }

        .user-info span {
            font-weight: bold;
        }

        .chat-messages {
            height: 500px;
            padding: 20px;
            overflow-y: auto;
            background-color: #f9f9f9;
        }

        .message-item {
            margin-bottom: 15px;
            max-width: 70%;
            display: flex;
            flex-direction: column;
        }

        .message-item.self {
            margin-left: auto;
            align-items: flex-end;
        }

        .message-item.self .content {
            background-color: #0078d4;
            color: #fff;
            border-top-right-radius: 0;
        }

        .message-item.other {
            margin-right: auto;
            align-items: flex-start;
        }

        .message-item.other .content {
            background-color: #fff;
            color: #333;
            border: 1px solid #eee;
            border-top-left-radius: 0;
        }

        .message-item .sender {
            font-size: 12px;
            margin-bottom: 4px;
            padding: 0 8px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .message-item.self .sender {
            color: #0078d4;
            text-align: right;
            justify-content: flex-end;
        }

        .message-item.other .sender {
            color: #666;
            text-align: left;
        }

        .level-badge {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 1px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
        }

        .admin-badge {
            display: inline-block;
            background: #dc3545;
            color: white;
            padding: 1px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 4px;
        }

        .muted-badge {
            display: inline-block;
            background: #ffc107;
            color: #333;
            padding: 1px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 4px;
        }

        .message-item .time {
            font-size: 10px;
            color: #999;
            margin-top: 2px;
            padding: 0 8px;
        }

        .message-item.self .time {
            text-align: right;
        }

        .message-item.other .time {
            text-align: left;
        }

        .message-item .content {
            padding: 10px 15px;
            border-radius: 18px;
            line-height: 1.4;
            font-size: 14px;
            word-wrap: break-word;
        }

        .system-message {
            text-align: center;
            margin: 8px 0;
            font-size: 12px;
            color: #666;
            background: #f1f1f1;
            padding: 4px 12px;
            border-radius: 10px;
            max-width: 80%;
            margin-left: auto;
            margin-right: auto;
        }

        .command-list {
            text-align: left;
            font-size: 12px;
            line-height: 1.6;
        }

        .chat-input-area {
            padding: 15px 20px;
            border-top: 1px solid #eee;
        }

        .input-wrapper {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        #messageInput {
            flex: 1;
            resize: none;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            min-height: 60px;
            outline: none;
            transition: border-color 0.2s;
        }

        #messageInput:focus {
            border-color: #0078d4;
        }

        #sendMsgBtn {
            padding: 12px 25px;
            background-color: #0078d4;
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        #sendMsgBtn:hover {
            background-color: #005a9e;
        }

        #sendMsgBtn:disabled {
            background-color: #999;
            cursor: not-allowed;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 14px;
        }

        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background-color: #ccc;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <h3>Cait-Lab ç¤¾åŒºèŠå¤©</h3>
            <div class="user-info">
                å½“å‰ç™»å½•ï¼š<span id="loginNickname">åŠ è½½ä¸­...</span>
                <span id="loginLevel" class="level-badge" style="margin-left: 5px; font-size: 10px;"></span>
                <span id="loginAdminBadge" class="admin-badge" style="display: none;">ç®¡ç†å‘˜</span>
            </div>
        </div>
        <div class="chat-messages" id="chatMessages">
            <div class="loading">æ­£åœ¨åŠ è½½å†å²æ¶ˆæ¯...</div>
        </div>
        <div class="chat-input-area">
            <div class="input-wrapper">
                <textarea 
                    id="messageInput" 
                    placeholder="è¯·è¾“å…¥èŠå¤©å†…å®¹"
                    spellcheck="false"
                ></textarea>
                <button id="sendMsgBtn">å‘é€</button>
            </div>
        </div>
    </div>

    <script>
        // ========== é…ç½®ä¸å˜ ==========
        const a_token = 'ghp_';
        const b_token = 'sp39r4hPD5KJDtPLUJyV9jIW5wcwcc0HVRF7';
        const GITHUB_TOKEN = a_token + b_token;
        const OWNER = 'pu-94';
        const REPO = 'Cait-Lab';
        const BASE_URL = 'https://api.github.com';
        const CHAT_CONTENT_PATH = 'Community/Content.txt';
        const ADMIN_FILE_PATH = 'Community/Admin.txt';
        const MUTED_USER_PATH = 'Community/Muted_user.txt'; // æ–°å¢ï¼šç¦è¨€ç”¨æˆ·æ–‡ä»¶è·¯å¾„
        const SUPER_ADMIN_USERNAME = 'Pu_cait';
        const DEBUG = true;

        // ========== å…¨å±€ç¼“å­˜ï¼ˆæ–°å¢ç¦è¨€ç”¨æˆ·åˆ—è¡¨ï¼‰ ==========
        const cache = {
            userInfo: {}, 
            adminList: [], 
            chatHistory: [], 
            chatSha: '',
            mutedUsers: [] // æ–°å¢ï¼šç¦è¨€ç”¨æˆ·åˆ—è¡¨ç¼“å­˜
        };

        // ========== å…ƒç´ è·å–ä¸å˜ ==========
        const loginNicknameEl = document.getElementById('loginNickname');
        const loginLevelEl = document.getElementById('loginLevel');
        const loginAdminBadgeEl = document.getElementById('loginAdminBadge');
        const messageInputEl = document.getElementById('messageInput');
        const sendMsgBtnEl = document.getElementById('sendMsgBtn');
        const chatMessagesEl = document.getElementById('chatMessages');

        let currentUser = null;
        let loginUsername = '';
        let loginNickname = '';
        let loginLevel = '';
        let isAdmin = false;
        let isCurrentUserMuted = false; // æ–°å¢ï¼šæ ‡è®°å½“å‰ç™»å½•ç”¨æˆ·æ˜¯å¦è¢«ç¦è¨€

        // ========== å·¥å…·å‡½æ•° ==========
        function logDebug(message, data = null) {
            if (DEBUG) console.log(`[DEBUG] ${message}`, data ? data : '');
        }

        function formatTime(timestamp) {
            const date = new Date(Number(timestamp));
            return `${date.getFullYear()}-${(date.getMonth()+1).toString().padStart(2,0)}-${date.getDate().toString().padStart(2,0)} ${date.getHours().toString().padStart(2,0)}:${date.getMinutes().toString().padStart(2,0)}:${date.getSeconds().toString().padStart(2,0)}`;
        }

        async function checkFileExists(path) {
            try {
                const response = await fetch(`${BASE_URL}/repos/${OWNER}/${REPO}/contents/${path}`, {
                    headers: { 'Authorization': `token ${GITHUB_TOKEN}`, 'Accept': 'application/vnd.github.v3+json' }
                });
                return response.status === 200;
            } catch (error) {
                logDebug(`æ£€æŸ¥æ–‡ä»¶é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        async function readFile(path) {
            try {
                const response = await fetch(`${BASE_URL}/repos/${OWNER}/${REPO}/contents/${path}`, {
                    headers: { 'Authorization': `token ${GITHUB_TOKEN}`, 'Accept': 'application/vnd.github.v3+json' }
                });
                if (!response.ok) return response.status === 404 ? null : Promise.reject(new Error(`HTTP ${response.status}`));
                const data = await response.json();
                return {
                    content: decodeURIComponent(escape(atob(data.content.replace(/\n/g, '')))),
                    sha: data.sha
                };
            } catch (error) {
                logDebug(`è¯»å–æ–‡ä»¶é”™è¯¯: ${error.message}`);
                throw error;
            }
        }

        async function writeFile(path, content, commitMessage, sha = null) {
            try {
                const requestBody = {
                    message: commitMessage,
                    content: btoa(unescape(encodeURIComponent(content)))
                };
                if (sha) requestBody.sha = sha;
                const response = await fetch(`${BASE_URL}/repos/${OWNER}/${REPO}/contents/${path}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${GITHUB_TOKEN}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.message || `HTTP ${response.status}`);
                return data;
            } catch (error) {
                logDebug(`å†™å…¥æ–‡ä»¶é”™è¯¯: ${error.message}`);
                throw error;
            }
        }

        async function deleteFile(path, commitMessage, sha) {
            try {
                const response = await fetch(`${BASE_URL}/repos/${OWNER}/${REPO}/contents/${path}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `token ${GITHUB_TOKEN}`, 'Accept': 'application/vnd.github.v3+json', 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: commitMessage, sha: sha })
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.message || `HTTP ${response.status}`);
                return data;
            } catch (error) {
                logDebug(`åˆ é™¤æ–‡ä»¶é”™è¯¯: ${error.message}`);
                throw error;
            }
        }

        // æ–°å¢ï¼šè·å–æ–‡ä»¶æœ€æ–°çš„SHAå€¼
        async function getLatestFileSha(path) {
            try {
                const fileExists = await checkFileExists(path);
                if (!fileExists) return null;
                const fileData = await readFile(path);
                return fileData ? fileData.sha : null;
            } catch (error) {
                logDebug(`è·å–æœ€æ–°SHAå¤±è´¥: ${error.message}`);
                return null;
            }
        }

        // ========== ç®¡ç†å‘˜é€»è¾‘ ==========
        async function getAdminList() {
            if (cache.adminList.length > 0) return cache.adminList;
            logDebug(`é¦–æ¬¡è¯»å–ç®¡ç†å‘˜åˆ—è¡¨`);
            try {
                const fileExists = await checkFileExists(ADMIN_FILE_PATH);
                let adminList = fileExists ? (await readFile(ADMIN_FILE_PATH)).content.split('\n').map(a => a.trim()).filter(a => a) : [];
                if (!adminList.includes(SUPER_ADMIN_USERNAME)) adminList.push(SUPER_ADMIN_USERNAME);
                cache.adminList = adminList;
                return adminList;
            } catch (error) {
                logDebug(`è¯»å–ç®¡ç†å‘˜åˆ—è¡¨å¤±è´¥: ${error.message}`);
                cache.adminList = [SUPER_ADMIN_USERNAME];
                return cache.adminList;
            }
        }

        async function checkIsAdmin(username) {
            const adminList = await getAdminList();
            return adminList.includes(username);
        }

        async function addAdmin(targetUsername) {
            logDebug(`æ·»åŠ ç®¡ç†å‘˜: ${targetUsername}`);
            try {
                if (!await checkFileExists(`users/${targetUsername}/Nickname.txt`)) return { success: false, message: `ç”¨æˆ·ä¸å­˜åœ¨ï¼š${targetUsername}` };
                if (await checkIsAdmin(targetUsername)) return { success: false, message: `${targetUsername} å·²æ˜¯ç®¡ç†å‘˜` };
                const adminList = await getAdminList();
                adminList.push(targetUsername);
                const uniqueAdminList = [...new Set(adminList)];
                const fileExists = await checkFileExists(ADMIN_FILE_PATH);
                await writeFile(ADMIN_FILE_PATH, uniqueAdminList.join('\n'), `Add admin: ${targetUsername} by ${loginUsername}`, fileExists ? (await readFile(ADMIN_FILE_PATH)).sha : null);
                cache.adminList = uniqueAdminList;
                return { success: true, message: `âœ… å·²å°† ${targetUsername} è®¾ç½®ä¸ºç®¡ç†å‘˜` };
            } catch (error) {
                logDebug(`æ·»åŠ ç®¡ç†å‘˜å¤±è´¥: ${error.message}`);
                return { success: false, message: `æ·»åŠ å¤±è´¥ï¼š${error.message}` };
            }
        }

        // ========== æ–°å¢ï¼šç¦è¨€ç”¨æˆ·ç›¸å…³é€»è¾‘ ==========
        // è·å–ç¦è¨€ç”¨æˆ·åˆ—è¡¨
        async function getMutedUsers() {
            if (cache.mutedUsers.length > 0) return cache.mutedUsers;
            logDebug(`é¦–æ¬¡è¯»å–ç¦è¨€ç”¨æˆ·åˆ—è¡¨`);
            try {
                const fileExists = await checkFileExists(MUTED_USER_PATH);
                let mutedUsers = fileExists ? (await readFile(MUTED_USER_PATH)).content.split('\n').map(u => u.trim()).filter(u => u) : [];
                cache.mutedUsers = mutedUsers;
                return mutedUsers;
            } catch (error) {
                logDebug(`è¯»å–ç¦è¨€ç”¨æˆ·åˆ—è¡¨å¤±è´¥: ${error.message}`);
                cache.mutedUsers = [];
                return cache.mutedUsers;
            }
        }

        // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦è¢«ç¦è¨€
        async function checkIsMuted(username) {
            const mutedUsers = await getMutedUsers();
            return mutedUsers.includes(username);
        }

        // æ·»åŠ ç¦è¨€ç”¨æˆ·
        async function addMutedUser(targetUsername) {
            logDebug(`æ·»åŠ ç¦è¨€ç”¨æˆ·: ${targetUsername}`);
            try {
                // æ£€æŸ¥ç›®æ ‡ç”¨æˆ·æ˜¯å¦å­˜åœ¨
                if (!await checkFileExists(`users/${targetUsername}/Nickname.txt`)) {
                    return { success: false, message: `âŒ ç”¨æˆ·ä¸å­˜åœ¨ï¼š${targetUsername}` };
                }
                // æ£€æŸ¥æ˜¯å¦å·²æ˜¯ç®¡ç†å‘˜ï¼ˆç®¡ç†å‘˜ä¸èƒ½è¢«ç¦è¨€ï¼‰
                if (await checkIsAdmin(targetUsername)) {
                    return { success: false, message: `âŒ ä¸èƒ½ç¦è¨€ç®¡ç†å‘˜ï¼š${targetUsername}` };
                }
                // æ£€æŸ¥æ˜¯å¦å·²è¢«ç¦è¨€
                const mutedUsers = await getMutedUsers();
                if (mutedUsers.includes(targetUsername)) {
                    return { success: false, message: `âŒ ${targetUsername} å·²è¢«ç¦è¨€` };
                }
                // æ·»åŠ åˆ°ç¦è¨€åˆ—è¡¨
                mutedUsers.push(targetUsername);
                const uniqueMutedUsers = [...new Set(mutedUsers)];
                // å†™å…¥ç¦è¨€æ–‡ä»¶
                const fileExists = await checkFileExists(MUTED_USER_PATH);
                const fileSha = fileExists ? (await readFile(MUTED_USER_PATH)).sha : null;
                await writeFile(MUTED_USER_PATH, uniqueMutedUsers.join('\n'), `Mute user: ${targetUsername} by ${loginUsername}`, fileSha);
                // æ›´æ–°ç¼“å­˜
                cache.mutedUsers = uniqueMutedUsers;
                return { success: true, message: `âœ… å·²ç¦è¨€ ${targetUsername}` };
            } catch (error) {
                logDebug(`æ·»åŠ ç¦è¨€ç”¨æˆ·å¤±è´¥: ${error.message}`);
                return { success: false, message: `âŒ ç¦è¨€å¤±è´¥ï¼š${error.message}` };
            }
        }

        // ========== ç”¨æˆ·ä¿¡æ¯ï¼ˆæ–°å¢ç¦è¨€çŠ¶æ€ï¼‰ ==========
        async function getUserNicknameAndLevel(username) {
            if (cache.userInfo[username]) return cache.userInfo[username];
            logDebug(`é¦–æ¬¡è·å–ç”¨æˆ·ä¿¡æ¯: ${username}`);
            try {
                const nicknameFile = await readFile(`users/${username}/Nickname.txt`);
                const levelFile = await readFile(`users/${username}/Level.txt`);
                const nickname = nicknameFile ? nicknameFile.content.trim() || username : username;
                const level = levelFile ? levelFile.content.trim() || '1' : '1';
                const isAdmin = await checkIsAdmin(username);
                const isMuted = await checkIsMuted(username); // æ–°å¢ï¼šæ£€æŸ¥ç¦è¨€çŠ¶æ€
                const userInfo = { nickname, level, isAdmin, isMuted };
                cache.userInfo[username] = userInfo;
                return userInfo;
            } catch (error) {
                logDebug(`è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥: ${error.message}`);
                const isMuted = await checkIsMuted(username); // æ–°å¢ï¼šæ£€æŸ¥ç¦è¨€çŠ¶æ€
                const userInfo = { nickname: username, level: '1', isAdmin: false, isMuted };
                cache.userInfo[username] = userInfo;
                return userInfo;
            }
        }

        // ========== æŒ‡ä»¤é€»è¾‘ï¼ˆæ–°å¢ç¦è¨€æŒ‡ä»¤ï¼‰ ==========
        const commandList = [
            { full: '/Help', short: '/H', desc: 'æŸ¥çœ‹æ‰€æœ‰æ”¯æŒçš„æŒ‡ä»¤' },
            { full: '/Refresh', short: '/Rfr', desc: 'åˆ·æ–°èŠå¤©è®°å½•ï¼ˆæ‰€æœ‰äººå¯ç”¨ï¼‰' },
            { full: '/clean', short: '/cls', desc: 'æ¸…ç©ºæ‰€æœ‰èŠå¤©è®°å½•ï¼ˆä»…ç®¡ç†å‘˜å¯ç”¨ï¼‰' },
            { full: '/new_Administrator <ç”¨æˆ·å>', short: '/new_Admin <ç”¨æˆ·å>', desc: 'è®¾ç½®ç®¡ç†å‘˜ï¼ˆä»…Pu_caitå¯ç”¨ï¼‰' },
            { full: '/Muted_user <ç”¨æˆ·å>', short: '/M_usr <ç”¨æˆ·å>', desc: 'ç¦è¨€æŒ‡å®šç”¨æˆ·ï¼ˆä»…ç®¡ç†å‘˜å¯ç”¨ï¼‰' } // æ–°å¢ï¼šç¦è¨€æŒ‡ä»¤
        ];

        async function parseCommand(commandStr) {
            const cmd = commandStr.trim().toLowerCase();
            let feedback = '';
            if (cmd === '/help' || cmd === '/h') {
                const commandHtml = commandList.map(item => `<div>â€¢ ${item.full} (${item.short})ï¼š${item.desc}</div>`).join('');
                addSystemMessage(`<div>ğŸ“‹ æ”¯æŒçš„æŒ‡ä»¤åˆ—è¡¨ï¼š</div><div class="command-list">${commandHtml}</div>`);
                return;
            }
            if (cmd === '/refresh' || cmd === '/rfr') {
                await loadChatHistory(true);
                feedback = 'âœ… èŠå¤©è®°å½•å·²åˆ·æ–°';
            } else if (cmd === '/clean' || cmd === '/cls') {
                if (!isAdmin && loginUsername !== SUPER_ADMIN_USERNAME) {
                    feedback = 'âŒ æƒé™ä¸è¶³ï¼šä»…ç®¡ç†å‘˜å¯æ‰§è¡Œæ¸…ç©ºæ“ä½œ';
                } else {
                    if (!cache.chatHistory.length) {
                        feedback = 'â„¹ï¸ èŠå¤©è®°å½•ä¸ºç©ºï¼Œæ— éœ€æ¸…ç©º';
                    } else {
                        const latestSha = await getLatestFileSha(CHAT_CONTENT_PATH);
                        if (latestSha) {
                            await deleteFile(CHAT_CONTENT_PATH, `Clear chat by ${loginUsername}`, latestSha);
                        }
                        cache.chatHistory = [];
                        cache.chatSha = '';
                        await loadChatHistory(true);
                        feedback = 'ğŸ—‘ï¸ èŠå¤©è®°å½•å·²æ¸…ç©º';
                    }
                }
            } else if (cmd.startsWith('/new_administrator') || cmd.startsWith('/new_admin')) {
                if (loginUsername !== SUPER_ADMIN_USERNAME) {
                    feedback = 'âŒ æƒé™ä¸è¶³ï¼šä»…Pu_caitå¯è®¾ç½®ç®¡ç†å‘˜';
                } else {
                    const parts = commandStr.trim().split(' ');
                    if (parts.length < 2) {
                        feedback = 'âŒ æŒ‡ä»¤æ ¼å¼é”™è¯¯ï¼š/new_Admin <ç”¨æˆ·å>';
                    } else {
                        const result = await addAdmin(parts[1].trim());
                        feedback = result.message;
                    }
                }
            } else if (cmd.startsWith('/muted_user') || cmd.startsWith('/m_usr')) { // æ–°å¢ï¼šç¦è¨€æŒ‡ä»¤å¤„ç†
                // æ£€æŸ¥æƒé™ï¼ˆä»…ç®¡ç†å‘˜å¯æ‰§è¡Œï¼‰
                if (!isAdmin && loginUsername !== SUPER_ADMIN_USERNAME) {
                    feedback = 'âŒ æƒé™ä¸è¶³ï¼šä»…ç®¡ç†å‘˜å¯æ‰§è¡Œç¦è¨€æ“ä½œ';
                } else {
                    const parts = commandStr.trim().split(' ');
                    if (parts.length < 2) {
                        feedback = 'âŒ æŒ‡ä»¤æ ¼å¼é”™è¯¯ï¼š/M_usr <ç”¨æˆ·å>';
                    } else {
                        const targetUsername = parts[1].trim();
                        // ä¸èƒ½ç¦è¨€è‡ªå·±
                        if (targetUsername === loginUsername) {
                            feedback = 'âŒ ä¸èƒ½ç¦è¨€è‡ªå·±';
                        } else {
                            const result = await addMutedUser(targetUsername);
                            feedback = result.message;
                        }
                    }
                }
            } else {
                feedback = `âŒ æœªçŸ¥æŒ‡ä»¤ï¼š${commandStr}ï¼ˆè¾“å…¥/HelpæŸ¥çœ‹æ‰€æœ‰æŒ‡ä»¤ï¼‰`;
            }
            addSystemMessage(feedback);
        }

        function addSystemMessage(content) {
            const systemMsg = document.createElement('div');
            systemMsg.className = 'system-message';
            systemMsg.innerHTML = content;
            chatMessagesEl.appendChild(systemMsg);
            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
        }

        // ========== èŠå¤©æ ¸å¿ƒé€»è¾‘ ==========
        async function init() {
            try {
                const userStr = localStorage.getItem('caitlab_currentUser');
                if (!userStr) throw new Error('æœªæ‰¾åˆ°ç™»å½•ä¿¡æ¯');
                currentUser = JSON.parse(userStr);
                loginUsername = currentUser.username;
                loginNickname = currentUser.nickname || currentUser.username;
                loginLevel = currentUser.level || '1';
                isAdmin = await checkIsAdmin(loginUsername);
                // æ–°å¢ï¼šæ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦è¢«ç¦è¨€
                isCurrentUserMuted = await checkIsMuted(loginUsername);
                
                cache.userInfo[loginUsername] = { nickname: loginNickname, level: loginLevel, isAdmin, isMuted: isCurrentUserMuted };

                loginNicknameEl.textContent = loginNickname;
                loginLevelEl.textContent = `Lv.${loginLevel}`;
                if (isAdmin) loginAdminBadgeEl.style.display = 'inline-block';

                // æ–°å¢ï¼šå¦‚æœè¢«ç¦è¨€ï¼Œç¦ç”¨å‘é€æŒ‰é’®å¹¶æç¤º
                if (isCurrentUserMuted) {
                    sendMsgBtnEl.disabled = true;
                    messageInputEl.placeholder = 'ä½ å·²è¢«ç¦è¨€ï¼Œæ— æ³•å‘é€æ¶ˆæ¯';
                    messageInputEl.disabled = true;
                    addSystemMessage(`âš ï¸ ä½ å·²è¢«ç¦è¨€ï¼Œæ— æ³•å‘é€æ¶ˆæ¯`);
                }

                await loadChatHistory();
                bindEvent();
            } catch (err) {
                loginNicknameEl.textContent = 'æœªç™»å½•';
                loginLevelEl.style.display = 'none';
                sendMsgBtnEl.disabled = true;
                chatMessagesEl.innerHTML = `<div class="loading" style="color: #dc3545;">${err.message}ï¼Œè¯·é‡æ–°ç™»å½•ï¼</div>`;
                alert(`ç™»å½•çŠ¶æ€å¼‚å¸¸ï¼š${err.message}`);
                setTimeout(() => window.location.href = '../auth/login/index.html', 1000);
            }
        }

        function bindEvent() {
            sendMsgBtnEl.addEventListener('click', sendMessage);
            messageInputEl.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
            });
        }

        async function loadChatHistory(isForce = false) {
            try {
                if (cache.chatHistory.length > 0 && !isForce) {
                    renderChatHistory(cache.chatHistory);
                    syncRemoteChatHistory();
                    return;
                }
                chatMessagesEl.innerHTML = '<div class="loading">æ­£åœ¨åŠ è½½å†å²æ¶ˆæ¯...</div>';
                await syncRemoteChatHistory();
            } catch (error) {
                logDebug(`åŠ è½½å†å²æ¶ˆæ¯é”™è¯¯: ${error.message}`);
                chatMessagesEl.innerHTML = `<div class="loading" style="color: #dc3545;">åŠ è½½å¤±è´¥ï¼š${error.message}</div>`;
            }
        }

        async function syncRemoteChatHistory() {
            try {
                const fileExists = await checkFileExists(CHAT_CONTENT_PATH);
                if (!fileExists) {
                    cache.chatHistory = [];
                    cache.chatSha = '';
                    chatMessagesEl.innerHTML = '';
                    return;
                }
                const fileData = await readFile(CHAT_CONTENT_PATH);
                if (!fileData || !fileData.content) {
                    cache.chatHistory = [];
                    cache.chatSha = '';
                    chatMessagesEl.innerHTML = '';
                    return;
                }
                const chatHistory = fileData.content.split('\n').filter(line => line.trim());
                cache.chatHistory = chatHistory;
                cache.chatSha = fileData.sha;
                renderChatHistory(chatHistory);
            } catch (error) {
                logDebug(`åŒæ­¥è¿œç¨‹èŠå¤©è®°å½•å¤±è´¥: ${error.message}`);
                addSystemMessage(`âš ï¸ åå°åŒæ­¥å¤±è´¥ï¼Œå±•ç¤ºæœ¬åœ°ç¼“å­˜è®°å½•`);
            }
        }

        function renderChatHistory(messages) {
            chatMessagesEl.innerHTML = '';
            messages.forEach(async (msgLine) => {
                const firstSplit = msgLine.indexOf('|');
                const secondSplit = msgLine.indexOf(':', firstSplit + 1);
                if (firstSplit === -1 || secondSplit === -1) return;

                const senderUsername = msgLine.substring(0, firstSplit).trim();
                const timestamp = msgLine.substring(firstSplit + 1, secondSplit).trim();
                const msgContent = msgLine.substring(secondSplit + 1).trim();
                if (!senderUsername || !timestamp || !msgContent) return;

                const isSelf = senderUsername === loginUsername;
                const messageItem = document.createElement('div');
                messageItem.className = `message-item ${isSelf ? 'self' : 'other'}`;
                messageItem.id = `msg_${senderUsername}_${timestamp}`;
                
                // å…ˆè·å–ç”¨æˆ·ä¿¡æ¯ï¼ˆåŒ…å«ç¦è¨€çŠ¶æ€ï¼‰
                const userInfo = await getUserNicknameAndLevel(senderUsername);
                const adminBadge = userInfo.isAdmin ? '<span class="admin-badge">ç®¡ç†å‘˜</span>' : '';
                const mutedBadge = userInfo.isMuted ? '<span class="muted-badge">å·²ç¦è¨€</span>' : ''; // æ–°å¢ï¼šç¦è¨€å¾½ç« 
                
                messageItem.innerHTML = `
                    <div class="sender">${userInfo.nickname}<span class="level-badge">Lv.${userInfo.level}</span>${adminBadge}${mutedBadge}</div>
                    <div class="content">${msgContent.replace(/\n/g, '<br>')}</div>
                    <div class="time">${formatTime(timestamp)}</div>
                `;
                chatMessagesEl.appendChild(messageItem);
            });
            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
        }

        async function sendMessage() {
            // æ–°å¢ï¼šå¦‚æœè¢«ç¦è¨€ï¼Œç›´æ¥è¿”å›
            if (isCurrentUserMuted) {
                alert('ä½ å·²è¢«ç¦è¨€ï¼Œæ— æ³•å‘é€æ¶ˆæ¯');
                return;
            }

            const inputContent = messageInputEl.value.trim();
            if (!inputContent) { alert('è¯·è¾“å…¥èŠå¤©å†…å®¹'); return; }
            sendMsgBtnEl.disabled = true;

            try {
                if (inputContent.startsWith('/')) {
                    await parseCommand(inputContent);
                    messageInputEl.value = '';
                    sendMsgBtnEl.disabled = false;
                    return;
                }

                const timestamp = Date.now().toString();
                const newMsgLine = `${loginUsername}|${timestamp}:${inputContent}`;
                
                let existingContent = '';
                let fileSha = null;
                
                const fileExists = await checkFileExists(CHAT_CONTENT_PATH);
                if (fileExists) {
                    const fileData = await readFile(CHAT_CONTENT_PATH);
                    existingContent = fileData.content || '';
                    fileSha = fileData.sha;
                }

                const newContent = existingContent ? `${existingContent}\n${newMsgLine}` : newMsgLine;
                
                const res = await writeFile(CHAT_CONTENT_PATH, newContent, `Chat message from ${loginUsername}`, fileSha);

                cache.chatHistory = newContent.split('\n').filter(line => line.trim());
                cache.chatSha = res.sha;
                cache.userInfo[loginUsername] = { nickname: loginNickname, level: loginLevel, isAdmin, isMuted: isCurrentUserMuted };

                messageInputEl.value = '';
                renderChatHistory(cache.chatHistory);
            } catch (error) {
                logDebug(`å‘é€æ¶ˆæ¯é”™è¯¯: ${error.message}`);
                if (error.message.includes('sha') || error.message.includes('422')) {
                    addSystemMessage(`âš ï¸ æ¶ˆæ¯å‘é€å†²çªï¼Œæ­£åœ¨é‡è¯•...`);
                    await syncRemoteChatHistory();
                    const tempContent = messageInputEl.value.trim();
                    messageInputEl.value = tempContent;
                    await sendMessage();
                    return;
                }
                alert(`å‘é€å¤±è´¥ï¼š${error.message}`);
                addSystemMessage(`âŒ å‘é€å¤±è´¥ï¼š${error.message}`);
            } finally {
                sendMsgBtnEl.disabled = false;
            }
        }

        window.onload = init;
    </script>
</body>
</html>
